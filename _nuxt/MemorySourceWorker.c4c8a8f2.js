import{o as I,bR as $,bk as Q,bp as M,t as Z,aB as _,r as F,bo as D,bT as P}from"./entry.a426b012.js";import{W as R,e as A,Q as C}from"./featureConversionUtils.6d559b11.js";import{t as k,n as G}from"./objectIdUtils.b29c2bc0.js";import{m as W}from"./FeatureStore.dd05c6e8.js";import{V as z,f as E,g as j}from"./QueryEngine.a997303e.js";import{a as B,n as L,l as V}from"./clientSideDefaults.e3a40a4b.js";import{y as U,u as g,d as T,c as x,h as q}from"./sourceUtils.24a0899f.js";import"./PooledRBush.9cdcc5f8.js";import"./quickselect.322ec8e1.js";import"./normalizeUtils.f1406d05.js";import"./WhereClause.5a06219b.js";import"./projection.b5b0482a.js";import"./ClassBreaksDefinition.95e31cb6.js";import"./OptimizedGeometry.3220611a.js";import"./OptimizedFeatureSet.1d1ac4b9.js";import"./aaBoundingRect.6a4b2723.js";import"./ItemCache.cf96c9c3.js";import"./json.48e3ea08.js";import"./QueryEngineCapabilities.5c978644.js";import"./utils.1b981ed6.js";var H=Object.defineProperty,N=Object.defineProperties,J=Object.getOwnPropertyDescriptors,w=Object.getOwnPropertySymbols,K=Object.prototype.hasOwnProperty,X=Object.prototype.propertyIsEnumerable,v=(f,e,t)=>e in f?H(f,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):f[e]=t,Y=(f,e)=>{for(var t in e||(e={}))K.call(e,t)&&v(f,t,e[t]);if(w)for(var t of w(e))X.call(e,t)&&v(f,t,e[t]);return f},ee=(f,e)=>N(f,J(e));const te=D,ie={xmin:-180,ymin:-90,xmax:180,ymax:90,spatialReference:D},re={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};function se(f){return P(f)?f.z!=null:!!f.hasZ}function ne(f){return P(f)?f.m!=null:!!f.hasM}class Oe{constructor(){this._queryEngine=null,this._nextObjectId=null}destroy(){this._queryEngine&&this._queryEngine&&this._queryEngine.destroy(),this._queryEngine=this._fieldsIndex=this._createDefaultAttributes=null}async load(e){const t=[],{features:n}=e,i=this._inferLayerProperties(n,e.fields),l=e.fields||[],p=e.hasM!=null?e.hasM:i.hasM,c=e.hasZ!=null?e.hasZ:i.hasZ,y=!e.spatialReference&&!i.spatialReference,u=y?te:e.spatialReference||i.spatialReference,a=y?ie:null,r=e.geometryType||i.geometryType,m=!r;let d=e.objectIdField||i.objectIdField,o=e.timeInfo;if(!m&&(y&&t.push({name:"feature-layer:spatial-reference-not-found",message:"Spatial reference not provided or found in features. Defaults to WGS84"}),!r))throw new I("feature-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");if(!d)throw new I("feature-layer:missing-property","objectIdField not set and couldn't be found in the provided fields");if(i.objectIdField&&d!==i.objectIdField&&(t.push({name:"feature-layer:duplicated-oid-field",message:`Provided objectIdField "${d}" doesn't match the field name "${i.objectIdField}", found in the provided fields`}),d=i.objectIdField),d&&!i.objectIdField){let s=null;l.some(h=>h.name===d&&(s=h,!0))?(s.type="esriFieldTypeOID",s.editable=!1,s.nullable=!1):l.unshift({alias:d,name:d,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const s of l){if(s.name==null&&(s.name=s.alias),s.alias==null&&(s.alias=s.name),!s.name)throw new I("feature-layer:invalid-field-name","field name is missing",{field:s});if(s.name===d&&(s.type="esriFieldTypeOID"),$.jsonValues.indexOf(s.type)===-1)throw new I("feature-layer:invalid-field-type",`invalid type for field "${s.name}"`,{field:s})}const b={};for(const s of l)if(s.type!=="esriFieldTypeOID"&&s.type!=="esriFieldTypeGlobalID"){const h=Q(s);h!==void 0&&(b[s.name]=h)}if(this._fieldsIndex=new M(l),this._createDefaultAttributes=B(b,d),o){if(o.startTimeField){const s=this._fieldsIndex.get(o.startTimeField);s?(o.startTimeField=s.name,s.type="esriFieldTypeDate"):o.startTimeField=null}if(o.endTimeField){const s=this._fieldsIndex.get(o.endTimeField);s?(o.endTimeField=s.name,s.type="esriFieldTypeDate"):o.endTimeField=null}if(o.trackIdField){const s=this._fieldsIndex.get(o.trackIdField);s?o.trackIdField=s.name:(o.trackIdField=null,t.push({name:"feature-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:o}}))}o.startTimeField||o.endTimeField||(t.push({name:"feature-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing or invalid",details:{timeInfo:o}}),o=null)}const O={warnings:t,featureErrors:[],layerDefinition:ee(Y({},re),{drawingInfo:L(r),templates:V(b),extent:a,geometryType:r,objectIdField:d,fields:l,hasZ:!!c,hasM:!!p,timeInfo:o}),assignedObjectIds:{}};if(this._queryEngine=new z({fields:l,geometryType:r,hasM:p,hasZ:c,objectIdField:d,spatialReference:u,featureStore:new W({geometryType:r,hasM:p,hasZ:c}),timeInfo:o,cacheSpatialQueries:!0}),!n||!n.length)return this._nextObjectId=k,O;const S=G(d,n);return this._nextObjectId=S+1,await E(n,u),this._loadInitialFeatures(O,n)}async applyEdits(e){const{spatialReference:t,geometryType:n}=this._queryEngine;return await Promise.all([U(t,n),E(e.adds,t),E(e.updates,t)]),this._applyEdits(e)}queryFeatures(e,t={}){return this._queryEngine.executeQuery(e,t.signal)}queryFeatureCount(e,t={}){return this._queryEngine.executeQueryForCount(e,t.signal)}queryObjectIds(e,t={}){return this._queryEngine.executeQueryForIds(e,t.signal)}queryExtent(e,t={}){return this._queryEngine.executeQueryForExtent(e,t.signal)}querySnapping(e,t={}){return this._queryEngine.executeQueryForSnapping(e,t.signal)}_inferLayerProperties(e,t){let n,i,l=null,p=null,c=null;for(const y of e){const u=y.geometry;if(!Z(u)&&(l||(l=_(u)),p||(p=u.spatialReference),n==null&&(n=se(u)),i==null&&(i=ne(u)),l&&p&&n!=null&&i!=null))break}if(t&&t.length){let y=null;t.some(u=>{const a=u.type==="esriFieldTypeOID",r=!u.type&&u.name&&u.name.toLowerCase()==="objectid";return y=u,a||r})&&(c=y.name)}return{geometryType:l,spatialReference:p,objectIdField:c,hasM:i,hasZ:n}}_loadInitialFeatures(e,t){const{geometryType:n,hasM:i,hasZ:l,objectIdField:p,spatialReference:c,featureStore:y}=this._queryEngine,u=[];for(const a of t){if(a.uid!=null&&(e.assignedObjectIds[a.uid]=-1),a.geometry&&n!==_(a.geometry)){e.featureErrors.push(g("Incorrect geometry type."));continue}const r=this._createDefaultAttributes(),m=T(this._fieldsIndex,r,a.attributes,!0,e.warnings);m?e.featureErrors.push(m):(this._assignObjectId(r,a.attributes,!0),a.attributes=r,a.uid!=null&&(e.assignedObjectIds[a.uid]=a.attributes[p]),F(a.geometry)&&(a.geometry=j(a.geometry,a.geometry.spatialReference,c)),u.push(a))}if(y.addMany(R([],u,n,l,i,p)),e.layerDefinition.extent=this._queryEngine.fullExtent,e.layerDefinition.timeInfo){const{start:a,end:r}=this._queryEngine.timeExtent;e.layerDefinition.timeInfo.timeExtent=[a,r]}return e}_applyEdits(e){const{adds:t,updates:n,deletes:i}=e,l={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t&&t.length&&this._applyAddEdits(l,t),n&&n.length&&this._applyUpdateEdits(l,n),i&&i.length){for(const p of i)l.deleteResults.push(x(p));this._queryEngine.featureStore.removeManyById(i)}return{fullExtent:this._queryEngine.fullExtent,featureEditResults:l}}_applyAddEdits(e,t){const{addResults:n}=e,{geometryType:i,hasM:l,hasZ:p,objectIdField:c,spatialReference:y,featureStore:u}=this._queryEngine,a=[];for(const r of t){if(r.geometry&&i!==_(r.geometry)){n.push(g("Incorrect geometry type."));continue}const m=this._createDefaultAttributes(),d=T(this._fieldsIndex,m,r.attributes);if(d)n.push(d);else{if(this._assignObjectId(m,r.attributes),r.attributes=m,r.uid!=null){const o=r.attributes[c];e.uidToObjectId[r.uid]=o}F(r.geometry)&&(r.geometry=j(q(r.geometry,y),r.geometry.spatialReference,y)),a.push(r),n.push(x(r.attributes[c]))}}u.addMany(R([],a,i,p,l,c))}_applyUpdateEdits({updateResults:e},t){const{geometryType:n,hasM:i,hasZ:l,objectIdField:p,spatialReference:c,featureStore:y}=this._queryEngine;for(const u of t){const{attributes:a,geometry:r}=u,m=a&&a[p];if(m==null){e.push(g(`Identifier field ${p} missing`));continue}if(!y.has(m)){e.push(g(`Feature with object id ${m} missing`));continue}const d=A(y.getFeature(m),n,l,i);if(F(r)){if(n!==_(r)){e.push(g("Incorrect geometry type."));continue}d.geometry=j(q(r,c),r.spatialReference,c)}if(a){const o=T(this._fieldsIndex,d.attributes,a);if(o){e.push(o);continue}}y.add(C(d,n,l,i,p)),e.push(x(m))}}_assignObjectId(e,t,n=!1){const i=this._queryEngine.objectIdField;n&&t&&isFinite(t[i])?e[i]=t[i]:e[i]=this._nextObjectId++}}export{Oe as default};
