import{q as u,u as d,f4 as $e,ad as be,ai as Ae,x as et,e7 as ie,a4 as W,N as $t,h as R,dg as U,dd as Me,ah as Fe,eS as Oe,p as De,t as it,cF as _e,r as f,M as Dt,j as E,_ as gt,v as Re,o as _t,bK as Pt,dL as At,bt as M,fH as qt,eM as Rt,a as Te,b6 as Ee,gq as Ce,cm as Ie,R as Le,a9 as Pe,br as jt,dR as St,dX as mt,bs as je,by as le,bE as dt,gr as Se,dQ as Ne,gs as ce,gt as ue,am as Ue,aj as ze}from"./entry.d0d45c75.js";import{a as lt,k as ht,q as Tt,L as yt,r as bt,M as We,x as ke,b as Nt,j as Ut,c as zt,O as Wt,h as kt,d as Ht,e as He,l as Et,f as Be}from"./georeference.d85d77dd.js";import{x as Ve}from"./earcut.d72b7070.js";import{n as Ge}from"./deduplicate.96384511.js";import{N,U as pe}from"./projection.9afbc7bb.js";import{d as he,e as fe}from"./vec33.4e0f4a42.js";import{a as Bt}from"./quat.98ba9431.js";import"./BufferView.6b43df21.js";import"./vec2.de7ae252.js";var Ze=Object.defineProperty,qe=Object.defineProperties,Je=Object.getOwnPropertyDescriptors,Jt=Object.getOwnPropertySymbols,Xe=Object.prototype.hasOwnProperty,Ye=Object.prototype.propertyIsEnumerable,Xt=(t,e,n)=>e in t?Ze(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,Vt=(t,e)=>{for(var n in e||(e={}))Xe.call(e,n)&&Xt(t,n,e[n]);if(Jt)for(var n of Jt(e))Ye.call(e,n)&&Xt(t,n,e[n]);return t},Gt=(t,e)=>qe(t,Je(e));function Qe(t,e,n,r){if(!e||!n)throw new Error("Cannot construct image data without dimensions");if(Yt)try{return new ImageData(t,e,n)}catch{Yt=!1}const o=Ke(e,n,r);return o.data.set(t,0),o}function Ke(t,e,n){return n||(n=tn()),n.getContext("2d").createImageData(t,e)}let nt=null,Yt=!0;function tn(){return nt||(nt=document.createElement("canvas"),nt.width=1,nt.height=1),nt}var q;const Mt=new WeakMap;let en=0,T=q=class extends $t{constructor(t){super(t),this.wrap="repeat"}get url(){return this._get("url")||null}set url(t){this._set("url",t),t&&this._set("data",null)}get data(){return this._get("data")||null}set data(t){this._set("data",t),t&&this._set("url",null)}writeData(t,e,n,r){if(t instanceof HTMLImageElement){const o={type:"image-element",src:qt(t.src,r),crossOrigin:t.crossOrigin};e[n]=o}else if(t instanceof HTMLCanvasElement){const o=t.getContext("2d").getImageData(0,0,t.width,t.height),s={type:"canvas-element",imageData:this._encodeImageData(o)};e[n]=s}else if(t instanceof HTMLVideoElement){const o={type:"video-element",src:qt(t.src,r),autoplay:t.autoplay,loop:t.loop,muted:t.muted,crossOrigin:t.crossOrigin,preload:t.preload};e[n]=o}else{const o={type:"image-data",imageData:this._encodeImageData(t)};e[n]=o}}readData(t){switch(t.type){case"image-element":{const e=new Image;return e.src=t.src,e.crossOrigin=t.crossOrigin,e}case"canvas-element":{const e=this._decodeImageData(t.imageData),n=document.createElement("canvas");return n.width=e.width,n.height=e.height,n.getContext("2d").putImageData(e,0,0),n}case"image-data":return this._decodeImageData(t.imageData);case"video-element":{const e=document.createElement("video");return e.src=t.src,e.crossOrigin=t.crossOrigin,e.autoplay=t.autoplay,e.loop=t.loop,e.muted=t.muted,e.preload=t.preload,e}default:return}}get transparent(){const t=this.data,e=this.url;if(t instanceof HTMLCanvasElement)return this._imageDataContainsTransparent(t.getContext("2d").getImageData(0,0,t.width,t.height));if(t instanceof ImageData)return this._imageDataContainsTransparent(t);if(e){const n=e.substr(e.length-4,4).toLowerCase(),r=e.substr(0,15).toLocaleLowerCase();if(n===".png"||r==="data:image/png;")return!0}return!1}set transparent(t){t!=null?this._override("transparent",t):this._clearOverride("transparent")}get contentHash(){const t=typeof this.wrap=="string"?this.wrap:typeof this.wrap=="object"?`${this.wrap.horizontal}/${this.wrap.vertical}`:"",e=(n="")=>`d:${n},t:${this.transparent},w:${t}`;return this.url!=null?e(this.url):this.data!=null?this.data instanceof HTMLImageElement||this.data instanceof HTMLVideoElement?e(this.data.src):(Mt.has(this.data)||Mt.set(this.data,++en),e(Mt.get(this.data))):e()}clone(){const t={url:this.url,data:this.data,wrap:this._cloneWrap()};return new q(t)}cloneWithDeduplication(t){const e=t.get(this);if(e)return e;const n=this.clone();return t.set(this,n),n}_cloneWrap(){return typeof this.wrap=="string"?this.wrap:{horizontal:this.wrap.horizontal,vertical:this.wrap.vertical}}_encodeImageData(t){let e="";for(let n=0;n<t.data.length;n++)e+=String.fromCharCode(t.data[n]);return{data:btoa(e),width:t.width,height:t.height}}_decodeImageData(t){const e=atob(t.data),n=new Uint8ClampedArray(e.length);for(let r=0;r<e.length;r++)n[r]=e.charCodeAt(r);return Qe(n,t.width,t.height)}_imageDataContainsTransparent(t){for(let e=3;e<t.data.length;e+=4)if(t.data[e]!==255)return!0;return!1}static from(t){return typeof t=="string"?new q({url:t}):t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof ImageData||t instanceof HTMLVideoElement?new q({data:t}):Rt(q,t)}};u([d({type:String,json:{write:$e}})],T.prototype,"url",null),u([d({json:{write:{overridePolicy(){return{enabled:!this.url}}}}}),d()],T.prototype,"data",null),u([be("data")],T.prototype,"writeData",null),u([Ae("data")],T.prototype,"readData",null),u([d({type:Boolean,json:{write:{overridePolicy(){return{enabled:this._isOverridden("transparent")}}}}})],T.prototype,"transparent",null),u([d({json:{write:!0}})],T.prototype,"wrap",void 0),u([d({readOnly:!0})],T.prototype,"contentHash",null),T=q=u([et("esri.geometry.support.MeshTexture")],T);const at=T;var Ct;let C=Ct=class extends $t{constructor(t){super(t),this.color=null,this.colorTexture=null,this.normalTexture=null,this.alphaMode="auto",this.alphaCutoff=.5,this.doubleSided=!0}clone(){return this.cloneWithDeduplication(null,new Map)}cloneWithDeduplication(t,e){const n=f(t)?t.get(this):null;if(n)return n;const r=new Ct(this.clonePropertiesWithDeduplication(e));return f(t)&&t.set(this,r),r}clonePropertiesWithDeduplication(t){return{color:f(this.color)?this.color.clone():null,colorTexture:f(this.colorTexture)?this.colorTexture.cloneWithDeduplication(t):null,normalTexture:f(this.normalTexture)?this.normalTexture.cloneWithDeduplication(t):null,alphaMode:this.alphaMode,alphaCutoff:this.alphaCutoff,doubleSided:this.doubleSided}}};u([d({type:ie,json:{write:!0}})],C.prototype,"color",void 0),u([d({type:at,json:{write:!0}})],C.prototype,"colorTexture",void 0),u([d({type:at,json:{write:!0}})],C.prototype,"normalTexture",void 0),u([d({nonNullable:!0,json:{write:!0}})],C.prototype,"alphaMode",void 0),u([d({nonNullable:!0,json:{write:!0}})],C.prototype,"alphaCutoff",void 0),u([d({nonNullable:!0,json:{write:!0}})],C.prototype,"doubleSided",void 0),C=Ct=u([et("esri.geometry.support.MeshMaterial")],C);const Zt=C;var It;let I=It=class extends Zt{constructor(t){super(t),this.emissiveColor=null,this.emissiveTexture=null,this.occlusionTexture=null,this.metallic=1,this.roughness=1,this.metallicRoughnessTexture=null}clone(){return this.cloneWithDeduplication(null,new Map)}cloneWithDeduplication(t,e){const n=f(t)?t.get(this):null;if(n)return n;const r=new It(this.clonePropertiesWithDeduplication(e));return f(t)&&t.set(this,r),r}clonePropertiesWithDeduplication(t){return Gt(Vt({},super.clonePropertiesWithDeduplication(t)),{emissiveColor:f(this.emissiveColor)?this.emissiveColor.clone():null,emissiveTexture:f(this.emissiveTexture)?this.emissiveTexture.cloneWithDeduplication(t):null,occlusionTexture:f(this.occlusionTexture)?this.occlusionTexture.cloneWithDeduplication(t):null,metallic:this.metallic,roughness:this.roughness,metallicRoughnessTexture:f(this.metallicRoughnessTexture)?this.metallicRoughnessTexture.cloneWithDeduplication(t):null})}};u([d({type:ie,json:{write:!0}})],I.prototype,"emissiveColor",void 0),u([d({type:at,json:{write:!0}})],I.prototype,"emissiveTexture",void 0),u([d({type:at,json:{write:!0}})],I.prototype,"occlusionTexture",void 0),u([d({type:Number,nonNullable:!0,json:{write:!0},range:{min:0,max:1}})],I.prototype,"metallic",void 0),u([d({type:Number,nonNullable:!0,json:{write:!0},range:{min:0,max:1}})],I.prototype,"roughness",void 0),u([d({type:at,json:{write:!0}})],I.prototype,"metallicRoughnessTexture",void 0),I=It=u([et("esri.geometry.support.MeshMaterialMetallicRoughness")],I);const nn=I;var ft;const H=W.getLogger("esri.geometry.support.MeshVertexAttributes");let A=ft=class extends $t{constructor(t){super(t),this.color=null,this.position=new Float64Array(0),this.uv=null,this.normal=null,this.tangent=null}castColor(t){return J(t,Uint8Array,[Uint8ClampedArray],{loggerTag:".color=",stride:4},H)}castPosition(t){return t&&t instanceof Float32Array&&H.warn(".position=","Setting position attribute from a Float32Array may cause precision problems. Consider storing data in a Float64Array or a regular number array"),J(t,Float64Array,[Float32Array],{loggerTag:".position=",stride:3},H)}castUv(t){return J(t,Float32Array,[Float64Array],{loggerTag:".uv=",stride:2},H)}castNormal(t){return J(t,Float32Array,[Float64Array],{loggerTag:".normal=",stride:3},H)}castTangent(t){return J(t,Float32Array,[Float64Array],{loggerTag:".tangent=",stride:4},H)}clone(){const t={position:R(this.position),uv:R(this.uv),normal:R(this.normal),tangent:R(this.tangent),color:R(this.color)};return new ft(t)}clonePositional(){const t={position:R(this.position),normal:R(this.normal),tangent:R(this.tangent),uv:this.uv,color:this.color};return new ft(t)}};function Ft(t,e,n,r){const{loggerTag:o,stride:s}=e;return t.length%s!=0?(r.error(o,`Invalid array length, expected a multiple of ${s}`),new n([])):t}function J(t,e,n,r,o){if(!t)return t;if(t instanceof e)return Ft(t,r,e,o);for(const s of n)if(t instanceof s)return Ft(new e(t),r,e,o);if(Array.isArray(t))return Ft(new e(t),r,e,o);{const s=n.map(a=>`'${a.name}'`);return o.error(`Failed to set property, expected one of ${s}, but got ${t.constructor.name}`),new e([])}}function rt(t,e,n){e[n]=rn(t)}function rn(t){const e=new Array(t.length);for(let n=0;n<t.length;n++)e[n]=t[n];return e}u([d({json:{write:rt}})],A.prototype,"color",void 0),u([U("color")],A.prototype,"castColor",null),u([d({nonNullable:!0,json:{write:rt}})],A.prototype,"position",void 0),u([U("position")],A.prototype,"castPosition",null),u([d({json:{write:rt}})],A.prototype,"uv",void 0),u([U("uv")],A.prototype,"castUv",null),u([d({json:{write:rt}})],A.prototype,"normal",void 0),u([U("normal")],A.prototype,"castNormal",null),u([d({json:{write:rt}})],A.prototype,"tangent",void 0),u([U("tangent")],A.prototype,"castTangent",null),A=ft=u([et("esri.geometry.support.MeshVertexAttributes")],A);var st;const on=W.getLogger("esri.geometry.support.MeshComponent");let L=st=class extends $t{constructor(t){super(t),this.faces=null,this.material=null,this.shading="source",this.trustSourceNormals=!1}static from(t){return Rt(st,t)}castFaces(t){return J(t,Uint32Array,[Uint16Array],{loggerTag:".faces=",stride:3},on)}castMaterial(t){return Rt(t&&typeof t=="object"&&("metallic"in t||"roughness"in t||"metallicRoughnessTexture"in t)?nn:Zt,t)}clone(){return new st({faces:R(this.faces),shading:this.shading,material:R(this.material),trustSourceNormals:this.trustSourceNormals})}cloneWithDeduplication(t,e){const n={faces:R(this.faces),shading:this.shading,material:this.material?this.material.cloneWithDeduplication(t,e):null,trustSourceNormals:this.trustSourceNormals};return new st(n)}};u([d({json:{write:!0}})],L.prototype,"faces",void 0),u([U("faces")],L.prototype,"castFaces",null),u([d({type:Zt,json:{write:!0}})],L.prototype,"material",void 0),u([U("material")],L.prototype,"castMaterial",null),u([d({type:String,json:{write:!0}})],L.prototype,"shading",void 0),u([d({type:Boolean})],L.prototype,"trustSourceNormals",void 0),L=st=u([et("esri.geometry.support.MeshComponent")],L);const K=L;function sn(t){const e=ln(t.rings,t.hasZ,wt.CCW_IS_HOLE),n=[];let r=0,o=0;for(const i of e.polygons){const c=i.count,l=i.index,g=new Float64Array(e.position.buffer,3*l*e.position.BYTES_PER_ELEMENT,3*c),m=i.holeIndices.map(h=>h-l),p=new Uint32Array(Ve(g,m,3));n.push({position:g,faces:p}),r+=g.length,o+=p.length}const s=an(n,r,o),a=Ge(s.position.buffer,6,{originalIndices:s.faces});return s.position=new Float64Array(a.buffer),s.faces=a.indices,s}function an(t,e,n){if(t.length===1)return t[0];const r=new Float64Array(e),o=new Uint32Array(n);let s=0,a=0,i=0;for(const c of t){for(let l=0;l<c.position.length;l++)r[s++]=c.position[l];for(let l=0;l<c.faces.length;l++)o[a++]=c.faces[l]+i;i=s/3}return{position:r,faces:o}}function ln(t,e,n){const r=t.length,o=new Array(r),s=new Array(r),a=new Array(r);let i=0,c=0,l=0,g=0;for(let h=0;h<r;++h)g+=t[h].length;const m=new Float64Array(3*g);let p=0;for(let h=r-1;h>=0;h--){const y=t[h],O=n===wt.CCW_IS_HOLE&&cn(y);if(O&&r!==1)o[i++]=y;else{let x=y.length;for(let w=0;w<i;++w)x+=o[w].length;const $={index:p,pathLengths:new Array(i+1),count:x,holeIndices:new Array(i)};$.pathLengths[0]=y.length,y.length>0&&(a[l++]={index:p,count:y.length}),p=O?ct(y,y.length-1,-1,m,p,y.length,e):ct(y,0,1,m,p,y.length,e);for(let w=0;w<i;++w){const b=o[w];$.holeIndices[w]=p,$.pathLengths[w+1]=b.length,b.length>0&&(a[l++]={index:p,count:b.length}),p=ct(b,0,1,m,p,b.length,e)}i=0,$.count>0&&(s[c++]=$)}}for(let h=0;h<i;++h){const y=o[h];y.length>0&&(a[l++]={index:p,count:y.length}),p=ct(y,0,1,m,p,y.length,e)}return c<r&&(s.length=c),l<r&&(a.length=l),{position:m,polygons:s,outlines:a}}function ct(t,e,n,r,o,s,a){o*=3;for(let i=0;i<s;++i){const c=t[e];r[o++]=c[0],r[o++]=c[1],r[o++]=a?c[2]:0,e+=n}return o/3}function cn(t){return!Te(t,!1,!1)}var wt;(function(t){t[t.NONE=0]="NONE",t[t.CCW_IS_HOLE=1]="CCW_IS_HOLE"})(wt||(wt={}));const Lt=W.getLogger("esri.geometry.support.meshUtils.centerAt");function un(t,e,n){var r;if(!t.vertexAttributes||!t.vertexAttributes.position)return;const o=(r=n==null?void 0:n.origin)!=null?r:t.origin;f(t.transform)?((n==null?void 0:n.geographic)!=null&&n.geographic!==t.transform.geographic&&Lt.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),pn(t.transform,e,o)):bt(t.spatialReference,n)?hn(t,e,o):fn(t,e,o)}function pn(t,e,n){const r=e.x-n.x,o=e.y-n.y,s=e.hasZ&&n.hasZ?e.z-n.z:0,a=t.origin;t.origin=[a[0]+r,a[1]+o,a[2]+s]}function hn(t,e,n){const r=We(t.vertexAttributes,n,{geographic:!0}),{position:o,normal:s,tangent:a}=ke(r,e,{geographic:!0});t.vertexAttributes.position=o,t.vertexAttributes.normal=s,t.vertexAttributes.tangent=a,t.vertexAttributesChanged()}function fn(t,e,n){const r=dn,o=mn;if(N(e,o,t.spatialReference)){if(!N(n,r,t.spatialReference)){const s=t.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,Lt.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}gn(t.vertexAttributes.position,o,r),t.vertexAttributesChanged()}else Lt.error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`)}function gn(t,e,n){if(t)for(let r=0;r<t.length;r+=3)for(let o=0;o<3;o++)t[r+o]+=e[o]-n[o]}const mn=M(),dn=M();async function yn(t,e,n){const{loadGLTFMesh:r}=await Pt(gt(()=>import("./loadGLTFMesh.1c37cb62.js"),["./loadGLTFMesh.1c37cb62.js","./entry.d0d45c75.js","./entry.ce60baa1.css","./vec33.4e0f4a42.js","./quat.98ba9431.js","./DefaultMaterial_COLOR_GAMMA.1d014571.js","./types.7008078d.js","./enums.ad15c731.js","./Version.7fd167c0.js","./BufferView.6b43df21.js","./vec2.de7ae252.js","./byteSizeEstimations.4dc27031.js","./georeference.d85d77dd.js","./projection.9afbc7bb.js","./earcut.d72b7070.js","./deduplicate.96384511.js"],import.meta.url),n),o=await ge(e,n),s=r(new E({x:0,y:0,z:0,spatialReference:t.spatialReference}),o.url,{resolveFile:wn(o),useTransform:!0,signal:f(n)?n.signal:null});s.then(()=>o.dispose(),()=>o.dispose());const{vertexAttributes:a,components:i}=await s;t.vertexAttributes=a,t.components=i}function wn(t){const e=Ee(t.url);return n=>{var r;const o=Ce(n,e,e),s=o?o.replace(/^ *\.\//,""):null;return(r=t.files.get(s))!=null?r:n}}async function ge(t,e){return t instanceof Blob?tt.fromBlob(t):typeof t=="string"?new tt(t):Array.isArray(t)?vn(t,e):xn(t,e)}async function vn(t,e){const n=new Map;let r=null;const o=await Ie(t.map(async a=>({name:a.name,source:await ge(a instanceof Blob?a:a.source,e)}))),s=[];for(const a of o)a&&(Le(e)?a.source.dispose():s.push(a));Pe(e);for(const{name:a,source:i}of s)(it(r)||/\.(gltf|glb)/i.test(a))&&(r=i.url),n.set(a,i.url),i.files&&i.files.forEach((c,l)=>n.set(l,c));if(it(r))throw new _t("mesh-load-external:missing-files","Missing files to load external mesh source");return new tt(r,()=>s.forEach(({source:a})=>a.dispose()),n)}async function xn(t,e){const{default:n}=await Pt(gt(()=>import("./entry.d0d45c75.js").then(o=>o.ht),["./entry.d0d45c75.js","./entry.ce60baa1.css"],import.meta.url).then(function(o){return o.hk}),e),r=typeof t.multipart[0]=="string"?await Promise.all(t.multipart.map(async o=>(await n(o,{responseType:"array-buffer"})).data)):t.multipart;return tt.fromBlob(new Blob(r))}class tt{constructor(e,n=()=>{},r=new Map){this.url=e,this.dispose=n,this.files=r}static fromBlob(e){const n=URL.createObjectURL(e);return new tt(n,()=>URL.revokeObjectURL(n))}}const $n=W.getLogger("esri.geometry.support.meshUtils.offset");function bn(t,e,n){t.vertexAttributes&&t.vertexAttributes.position&&(f(t.transform)?((n==null?void 0:n.geographic)!=null&&n.geographic!==t.transform.geographic&&$n.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),An(t.transform,e)):bt(t.spatialReference,n)?Mn(t,e):Fn(t,e))}function An(t,e){const n=t.origin;t.origin=jt(M(),n,e)}function Mn(t,e){const n=t.spatialReference,r=t.vertexAttributes.position,o=t.vertexAttributes.normal,s=t.vertexAttributes.tangent,a=new Float64Array(r.length),i=f(o)?new Float32Array(o.length):null,c=f(s)?new Float32Array(s.length):null,l=t.extent.center,g=On;pe(n,[l.x,l.y,l.z],Qt,St(n)),he(Kt,Qt),mt(g,e,Kt),Nt(r,n,a),f(o)&&Ut(o,r,a,n,i),f(s)&&zt(s,r,a,n,c),me(a,g),Wt(a,r,n),f(o)&&kt(i,r,a,n,o),f(s)&&Ht(c,r,a,n,s),t.vertexAttributesChanged()}function Fn(t,e){me(t.vertexAttributes.position,e),t.vertexAttributesChanged()}function me(t,e){if(t)for(let n=0;n<t.length;n+=3)for(let r=0;r<3;r++)t[n+r]+=e[r]}const On=M(),Qt=fe(),Kt=Bt();function Dn(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:n}=Pn,r=4*t.length,o=new Float64Array(3*r),s=new Float32Array(3*r),a=new Float32Array(2*r),i=new Uint32Array(2*t.length*3);let c=0,l=0,g=0,m=0;for(let p=0;p<t.length;p++){const h=t[p],y=c/3;for(const x of e)i[m++]=y+x;const O=h.corners;for(let x=0;x<4;x++){const $=O[x];let w=0;a[g++]=.25*n[x][0]+h.uvOrigin[0],a[g++]=h.uvOrigin[1]-.25*n[x][1];for(let b=0;b<3;b++)h.axis[b]!==0?(o[c++]=.5*h.axis[b],s[l++]=h.axis[b]):(o[c++]=.5*$[w++],s[l++]=0)}}return{position:o,normal:s,uv:a,faces:i}}function _n(t,e){const n=t.components[0],r=n.faces,o=jn[e],s=6*o,a=new Uint32Array(6),i=new Uint32Array(r.length-6);let c=0,l=0;for(let g=0;g<r.length;g++)g>=s&&g<s+6?a[c++]=r[g]:i[l++]=r[g];if(f(t.vertexAttributes.uv)){const g=new Float32Array(t.vertexAttributes.uv),m=4*o*2,p=[0,1,1,1,1,0,0,0];for(let h=0;h<p.length;h++)g[m+h]=p[h];t.vertexAttributes.uv=g}return t.components=[new K({faces:a,material:n.material}),new K({faces:i})],t}function Rn(t=0){const e=Math.round(8*2**t),n=2*e,r=(e-1)*(n+1)+2*n,o=new Float64Array(3*r),s=new Float32Array(3*r),a=new Float32Array(2*r),i=new Uint32Array(3*((e-1)*n*2));let c=0,l=0,g=0,m=0;for(let p=0;p<=e;p++){const h=p/e*Math.PI+.5*Math.PI,y=Math.cos(h),O=Math.sin(h);v[2]=O;const x=p===0||p===e,$=x?n-1:n;for(let w=0;w<=$;w++){const b=w/$*2*Math.PI;v[0]=-Math.sin(b)*y,v[1]=Math.cos(b)*y;for(let P=0;P<3;P++)o[c]=.5*v[P],s[c]=v[P],++c;a[l++]=(w+(x?.5:0))/n,a[l++]=p/e,p!==0&&w!==n&&(p!==e&&(i[g++]=m,i[g++]=m+1,i[g++]=m-n),p!==1&&(i[g++]=m,i[g++]=m-n,i[g++]=m-n-1)),m++}}return{position:o,normal:s,uv:a,faces:i}}function Tn(t=0){const n=Math.round(16*2**t),r=(5-1)*(n+1)+2*n,o=new Float64Array(3*r),s=new Float32Array(3*r),a=new Float32Array(2*r),i=new Uint32Array(3*(4*n));let c=0,l=0,g=0,m=0,p=0;for(let h=0;h<=5;h++){const y=h===0||h===5,O=h<=1||h>=5-1,x=h===2||h===4,$=y?n-1:n;for(let w=0;w<=$;w++){const b=w/$*2*Math.PI,P=y?0:.5;v[0]=P*Math.sin(b),v[1]=P*-Math.cos(b),v[2]=h<=2?.5:-.5;for(let k=0;k<3;k++)o[c++]=v[k],s[l++]=O?k===2?h<=1?1:-1:0:k===2?0:v[k]/P;a[g++]=(w+(y?.5:0))/n,a[g++]=h<=1?1*h/3:h<=3?1*(h-2)/3+1/3:1*(h-4)/3+2/3,x||h===0||w===n||(h!==5&&(i[m++]=p,i[m++]=p+1,i[m++]=p-n),h!==1&&(i[m++]=p,i[m++]=p-n,i[m++]=p-n-1)),p++}}return{position:o,normal:s,uv:a,faces:i}}function En(t,e){const n=typeof e=="number"?e:e!=null?e.width:1,r=typeof e=="number"?e:e!=null?e.height:1;switch(t){case"up":case"down":return{width:n,depth:r};case"north":case"south":return{width:n,height:r};case"east":case"west":return{depth:n,height:r}}}function Cn(t){const e=ot.facingAxisOrderSwap[t],n=ot.position,r=ot.normal,o=new Float64Array(n.length),s=new Float32Array(r.length);let a=0;for(let i=0;i<4;i++){const c=a;for(let l=0;l<3;l++){const g=e[l],m=Math.abs(g)-1,p=g>=0?1:-1;o[a]=n[c+m]*p,s[a]=r[c+m]*p,a++}}return{position:o,normal:s,uv:new Float32Array(ot.uv),faces:new Uint32Array(ot.faces)}}const B=1,V=2,G=3,ot={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[G,B,V],west:[-G,-B,V],north:[-B,G,V],south:[B,-G,V],up:[B,V,G],down:[B,-V,-G]}};function ut(t,e,n){In(t),Ln(t,n&&n.size);const{vertexAttributes:r,transform:o}=He(t,e,n);return{vertexAttributes:new A(Gt(Vt({},r),{uv:t.uv})),transform:o,components:[new K({faces:t.faces,material:n&&n.material||null})],spatialReference:e.spatialReference}}function In(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5}function Ln(t,e){if(e==null)return;const n=typeof e=="number"?[e,e,e]:[e.width!=null?e.width:1,e.depth!=null?e.depth:1,e.height!=null?e.height:1];j[0]=n[0],j[4]=n[1],j[8]=n[2];for(let r=0;r<t.position.length;r+=3){for(let o=0;o<3;o++)v[o]=t.position[r+o];mt(v,v,j);for(let o=0;o<3;o++)t.position[r+o]=v[o]}if(n[0]!==n[1]||n[1]!==n[2]){j[0]=1/n[0],j[4]=1/n[1],j[8]=1/n[2];for(let r=0;r<t.normal.length;r+=3){for(let o=0;o<3;o++)v[o]=t.normal[r+o];mt(v,v,j),je(v,v);for(let o=0;o<3;o++)t.normal[r+o]=v[o]}}}const Pn={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},jn={south:0,east:1,north:2,west:3,up:4,down:5},v=M(),j=Bt(),de=W.getLogger("esri.geometry.support.meshUtils.rotate");function Sn(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position||e[3]===0)return;const r=t.spatialReference;if(f(t.transform)){var o;(n==null?void 0:n.geographic)!=null&&n.geographic!==t.transform.geographic&&de.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const a=(o=n==null?void 0:n.origin)!=null?o:t.transform.getOriginPoint(r);Nn(t.transform,e,a)}else{var s;const a=(s=n==null?void 0:n.origin)!=null?s:t.origin;bt(t.spatialReference,n)?Un(t,e,a):zn(t,e,a)}}function Nn(t,e,n){const r=le(X,n.x,n.y,n.z),o=dt(X,r,t.origin);t.applyLocalInverse(o,te),t.rotation=Tt(t.rotation,e,lt()),t.applyLocalInverse(o,o),dt(o,o,te),t.translation=jt(M(),t.translation,o)}function Un(t,e,n){const r=t.spatialReference,o=St(r),s=ye;N(n,s,o)||N(t.origin,s,o);const a=t.vertexAttributes.position,i=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,l=new Float64Array(a.length),g=f(i)?new Float32Array(i.length):null,m=f(c)?new Float32Array(c.length):null;pe(o,s,vt,o),he(ne,vt);const p=ee;mt(Et(ee),Et(e),ne),p[3]=e[3],Nt(a,r,l),f(i)&&Ut(i,a,l,r,g),f(c)&&zt(c,a,l,r,m),Q(l,p,3,s),Wt(l,a,r),f(i)&&(Q(g,p,3),kt(g,a,l,r,i)),f(c)&&(Q(m,p,4),Ht(m,a,l,r,c)),t.vertexAttributesChanged()}function zn(t,e,n){const r=ye;if(!N(n,r,t.spatialReference)){const o=t.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,de.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}Q(t.vertexAttributes.position,e,3,r),Q(t.vertexAttributes.normal,e,3),Q(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}function Q(t,e,n,r=ce){if(!it(t)){Se(vt,Be(e),Et(e));for(let o=0;o<t.length;o+=n){for(let s=0;s<3;s++)X[s]=t[o+s]-r[s];Ne(X,X,vt);for(let s=0;s<3;s++)t[o+s]=X[s]+r[s]}}}const X=M(),te=M(),ee=lt(),vt=fe(),ne=Bt(),ye=M(),we=W.getLogger("esri.geometry.support.meshUtils.scale");function Wn(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=t.spatialReference;if(f(t.transform)){var o;(n==null?void 0:n.geographic)!=null&&n.geographic!==t.transform.geographic&&we.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const s=(o=n==null?void 0:n.origin)!=null?o:t.transform.getOriginPoint(r);kn(t.transform,e,s)}else{const s=bt(t.spatialReference,n),a=n&&n.origin||t.origin;s?Hn(t,e,a):Bn(t,e,a)}}function kn(t,e,n){const r=le(Y,n.x,n.y,n.z),o=dt(Y,r,t.origin);t.applyLocalInverse(o,re);const s=ue(M(),t.scale,e);t.scale=s,t.applyLocalInverse(o,o),dt(o,o,re),t.translation=jt(M(),t.translation,o)}function Hn(t,e,n){const r=t.spatialReference,o=St(r),s=xe;N(n,s,o)||N(t.origin,s,o);const a=t.vertexAttributes.position,i=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,l=new Float64Array(a.length),g=f(i)?new Float32Array(i.length):null,m=f(c)?new Float32Array(c.length):null;Nt(a,r,l),f(i)&&Ut(i,a,l,r,g),f(c)&&zt(c,a,l,r,m),ve(l,e,s),Wt(l,a,r),f(i)&&kt(g,a,l,r,i),f(c)&&Ht(m,a,l,r,c),t.vertexAttributesChanged()}function Bn(t,e,n){const r=xe;if(!N(n,r,t.spatialReference)){const o=t.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,we.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}ve(t.vertexAttributes.position,e,r),t.vertexAttributesChanged()}function ve(t,e,n=ce){if(t)for(let r=0;r<t.length;r+=3){for(let o=0;o<3;o++)Y[o]=t[r+o]-n[o];ue(Y,Y,e);for(let o=0;o<3;o++)t[r+o]=Y[o]+n[o]}}const Y=M(),re=M(),xe=M();var _;const D=W.getLogger("esri.geometry.Mesh");let F=_=class extends Me(Fe.LoadableMixin(Oe(De))){constructor(t){super(t),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new A,this.type="mesh"}initialize(){(it(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.handles.add(_e(()=>{var t;return{vertexAttributes:this.vertexAttributes,components:(t=this.components)==null?void 0:t.map(e=>e.clone()),transform:f(this.transform)?this.transform.clone():null}},()=>this._set("external",null),{once:!0,sync:!0}))})}get hasExtent(){return!this.loaded&&f(this.external)&&f(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const t=this.vertexAttributes.position,e=this.spatialReference;if(t.length===0||this.components&&this.components.length===0)return{extent:new Dt({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:e}),center:new E({x:0,y:0,z:0,spatialReference:e})};const n=f(this.transform)?this.transform.project(t,e):t;let r=1/0,o=1/0,s=1/0,a=-1/0,i=-1/0,c=-1/0,l=0,g=0,m=0;const p=n.length,h=1/(p/3);let y=0;for(;y<p;){const O=n[y++],x=n[y++],$=n[y++];r=Math.min(r,O),o=Math.min(o,x),s=Math.min(s,$),a=Math.max(a,O),i=Math.max(i,x),c=Math.max(c,$),l+=h*O,g+=h*x,m+=h*$}return{extent:new Dt({xmin:r,ymin:o,zmin:s,xmax:a,ymax:i,zmax:c,spatialReference:e}),center:new E({x:l,y:g,z:m,spatialReference:e})}}get anchor(){if(f(this.transform))return this.transform.getOriginPoint(this.spatialReference);const t=this.boundingInfo;return new E({x:t.center.x,y:t.center.y,z:t.extent.zmin,spatialReference:this.spatialReference})}get origin(){return f(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&f(this.external)&&f(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push(K.from(t)),this.notifyChange("components")):D.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const e=this.components.indexOf(t);if(e!==-1)return this.components.splice(e,1),void this.notifyChange("components")}D.error("removeComponent()","Provided component is not part of the list of components")}else D.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,e,n,r){return ht(Ot.x,t,Z),ht(Ot.y,e,oe),ht(Ot.z,n,se),Tt(Z,oe,Z),Tt(Z,se,Z),Sn(this,Z,r),this}offset(t,e,n,r){return this.loaded?(pt[0]=t,pt[1]=e,pt[2]=n,bn(this,pt,r),this):(D.error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,e){return this.loaded?(Wn(this,t,e),this):(D.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,e){return this.loaded?(un(this,t,e),this):(D.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){return f(this.external)&&this.addResolvingPromise(yn(this,this.external.source,t)),Promise.resolve(this)}clone(){const t=this.components?new Map:null,e=this.components?new Map:null,n={components:this.components?this.components.map(r=>r.cloneWithDeduplication(t,e)):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:f(this.transform)?this.transform.clone():null,external:f(this.external)?{source:this.external.source,extent:f(this.external.extent)?this.external.extent.clone():null}:null};return new _(n)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const{toBinaryGLTF:e}=await gt(()=>import("./gltfexport.97136cb7.js"),["./gltfexport.97136cb7.js","./entry.d0d45c75.js","./entry.ce60baa1.css","./quat.98ba9431.js","./georeference.d85d77dd.js","./vec33.4e0f4a42.js","./projection.9afbc7bb.js","./BufferView.6b43df21.js","./vec2.de7ae252.js","./enums.ad15c731.js","./earcut.d72b7070.js","./deduplicate.96384511.js"],import.meta.url);return e(this,t)}static createBox(t,e){if(!(t instanceof E))return D.error(".createBox()","expected location to be a Point instance"),null;const n=new _(ut(Dn(),t,e));return e&&e.imageFace&&e.imageFace!=="all"?_n(n,e.imageFace):n}static createSphere(t,e){return t instanceof E?new _(ut(Rn(e&&e.densificationFactor||0),t,e)):(D.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,e){return t instanceof E?new _(ut(Tn(e&&e.densificationFactor||0),t,e)):(D.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,e){var n;if(!(t instanceof E))return D.error(".createPlane()","expected location to be a Point instance"),null;const r=(n=e==null?void 0:e.facing)!=null?n:"up",o=En(r,e==null?void 0:e.size);return new _(ut(Cn(r),t,Gt(Vt({},e),{size:o})))}static createFromPolygon(t,e){if(!(t instanceof Re))return D.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const n=sn(t);return new _({vertexAttributes:new A({position:n.position}),components:[new K({faces:n.faces,shading:"flat",material:e&&e.material||null})],spatialReference:t.spatialReference})}static async createFromGLTF(t,e,n){if(!(t instanceof E))throw D.error(".createfromGLTF()","expected location to be a Point instance"),new _t("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=await Pt(gt(()=>import("./loadGLTFMesh.1c37cb62.js"),["./loadGLTFMesh.1c37cb62.js","./entry.d0d45c75.js","./entry.ce60baa1.css","./vec33.4e0f4a42.js","./quat.98ba9431.js","./DefaultMaterial_COLOR_GAMMA.1d014571.js","./types.7008078d.js","./enums.ad15c731.js","./Version.7fd167c0.js","./BufferView.6b43df21.js","./vec2.de7ae252.js","./byteSizeEstimations.4dc27031.js","./georeference.d85d77dd.js","./projection.9afbc7bb.js","./earcut.d72b7070.js","./deduplicate.96384511.js"],import.meta.url),n);return new _(await r(t,e,n))}static createWithExternalSource(t,e,n){var r,o,s;const a=(r=n==null?void 0:n.extent)!=null?r:null,i=(o=n==null?void 0:n.transform.clone())!=null?o:new yt;i.origin=[t.x,t.y,(s=t.z)!=null?s:0];const c=t.spatialReference;return new _({external:{source:e,extent:a},transform:i,spatialReference:c})}static createIncomplete(t,e){var n,r;const o=(n=e==null?void 0:e.transform.clone())!=null?n:new yt;o.origin=[t.x,t.y,(r=t.z)!=null?r:0];const s=t.spatialReference,a=new _({transform:o,spatialReference:s});return a.addResolvingPromise(Promise.reject(new _t("mesh-incomplete","Mesh resources are not complete"))),a}};u([d({type:[K],json:{write:!0}})],F.prototype,"components",void 0),u([d({type:yt,json:{write:!0}})],F.prototype,"transform",void 0),u([d({constructOnly:!0})],F.prototype,"external",void 0),u([d({readOnly:!0})],F.prototype,"hasExtent",null),u([d({readOnly:!0})],F.prototype,"boundingInfo",null),u([d({readOnly:!0})],F.prototype,"anchor",null),u([d({readOnly:!0})],F.prototype,"origin",null),u([d({readOnly:!0,json:{read:!1}})],F.prototype,"extent",null),u([d({readOnly:!0,json:{read:!1,write:!0,default:!0}})],F.prototype,"hasZ",void 0),u([d({readOnly:!0,json:{read:!1,write:!0,default:!1}})],F.prototype,"hasM",void 0),u([d({type:A,nonNullable:!0,json:{write:!0}})],F.prototype,"vertexAttributes",void 0),F=_=u([et("esri.geometry.Mesh")],F);const Ot={x:At(1,0,0),y:At(0,1,0),z:At(0,0,1)},Z=lt(),oe=lt(),se=lt(),pt=M(),ae=F;var z,xt;(function(t){t.featureGUID="featureGUID",t.assetName="assetName",t.hash="hash",t.type="type",t.conversionStatus="conversionStatus",t.flags="flags",t.complexity="complexity",t.size="size",t.seqNo="seqNo",t.sourceHash="sourceHash",t.assetURL="assetURL"})(z||(z={})),function(t){t.SUBMITTED="SUBMITTED",t.INPROGRESS="INPROGRESS",t.FAILED="FAILED",t.COMPLETED="COMPLETED"}(xt||(xt={}));function Vn(t,e,n){const r=n.features;n.features=[],delete n.geometryType;const o=Ue.fromJSON(n);o.geometryType="mesh";const s=o.spatialReference,a=it(t.outFields)||!t.outFields.length?()=>({}):Gn(t.outFields.includes("*")?null:new Set(t.outFields));for(const i of r){const c=Zn(i,s,e);f(c)&&o.features.push(new ze({geometry:c,attributes:a(i)}))}return o}function Gn(t){return({attributes:e})=>{if(!e)return{};if(!t)return e;for(const n in e)t.has(n)||delete e[n];return e}}function Zn(t,e,n){const{status:r,source:o}=Xn(t);if(r===S.FAILED)return null;const s=qn(t,e,n),a=Dt.fromJSON(t.geometry);a.spatialReference=e;const i=Jn(t,n);return r===S.PENDING?ae.createIncomplete(s,{extent:a,transform:i}):ae.createWithExternalSource(s,o,{extent:a,transform:i})}function qn({attributes:t},e,{transformFieldRoles:n}){return new E({x:t[n.originX],y:t[n.originY],z:t[n.originZ],spatialReference:e})}function Jn({attributes:t,assetMappings:e},{transformFieldRoles:n}){var r;return new yt({translation:[t[n.translationX],t[n.translationY],t[n.translationZ]],rotation:ht([t[n.rotationX],t[n.rotationY],t[n.rotationZ]],t[n.rotationDeg]),scale:[t[n.scaleX],t[n.scaleY],t[n.scaleZ]],geographic:!((r=e[z.flags])!=null&&r.includes("PROJECT_VERTICES"))})}function Xn(t){if(!t.assetMappings)return{status:S.FAILED};const e=[],n=new Map;for(const r of t.assetMappings){const o=r[z.seqNo],s=r[z.assetName],a=r[z.assetURL],i=r[z.conversionStatus];if(i===xt.FAILED)return{status:S.FAILED};if(i!==xt.COMPLETED)return{status:S.PENDING};if(o==null)e.push({name:s,source:a});else{const c=n.get(s);let l;c?l=c.multipart:(l=[],e.push({name:s,source:{multipart:l}}),n.set(s,{multipart:l})),l[o]=a}}return{status:S.COMPLETED,source:e}}var S;(function(t){t[t.FAILED=0]="FAILED",t[t.PENDING=1]="PENDING",t[t.COMPLETED=2]="COMPLETED"})(S||(S={}));var ar=Object.freeze(Object.defineProperty({__proto__:null,meshFeatureSetFromJSON:Vn},Symbol.toStringTag,{value:"Module"}));export{ar as a,nn as c,K as f,at as m,A as p};
